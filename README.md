# LearnRecord

## 基础知识
### 1、手机界面是怎么显示出东西来的？ ### 

手机的显示分为硬件显示和软件显示，其中软件显示分为如下几个步骤：

**一、应用启动与界面构建**
当用户点击应用图标时，操作系统会加载应用的代码和资源。应用通过UI 框架（如 Android 的 Jetpack Compose、iOS 的 SwiftUI 或跨平台的 Flutter）定义界面结构，例如按钮、文本框、图片等元素的位置和样式。这些界面元素会被抽象为视图树（View Tree），每个节点代表一个可交互的组件。
以 Android 为例，应用启动后会通过Activity的onCreate方法加载布局文件（如 XML 或 Compose 代码），系统会根据屏幕尺寸、分辨率等参数计算每个视图的位置和大小（onMeasure和onLayout过程），最终生成一个包含所有绘制指令的显示列表（DisplayList）。iOS 则通过UIKit或SwiftUI构建类似的视图层级，并利用Core Animation管理图层合成。

**二、渲染管线：从代码到像素**
应用的界面元素需要经过GPU 渲染才能转化为屏幕上的像素。这一过程分为以下步骤：
1. 图形数据处理
CPU 预处理：CPU 将视图树中的绘制指令（如颜色、形状、纹理）转换为 GPU 能理解的格式（如顶点数据、纹理坐标）。例如，一个圆形按钮会被拆解为一系列三角形顶点坐标。
GPU 加速渲染：GPU 通过顶点着色器（处理顶点位置）和片段着色器（计算像素颜色）对图形数据进行并行计算。例如，复杂的 3D 游戏场景或动画效果依赖 GPU 的高性能计算能力。
2. 缓冲区管理
双缓冲机制：为避免画面撕裂，GPU 会使用两个缓冲区（前缓冲和后缓冲）。GPU 先在后台缓冲区渲染下一帧画面，待渲染完成后，通过 ** 垂直同步信号（VSync）** 将前后缓冲区交换，确保显示器逐行扫描时显示完整的一帧。
三缓冲优化：部分系统（如 Android 12+）引入三缓冲机制，允许 GPU 提前渲染下一帧，进一步减少卡顿。
3. 图层合成
SurfaceFlinger（Android）：系统服务SurfaceFlinger负责将所有应用的图层（如应用界面、状态栏、导航栏）合成为最终画面。它通过共享内存（GraphicBuffer）获取各应用的渲染结果，并根据 Z 轴顺序（层级关系）进行混合。
Core Animation（iOS）：iOS 通过Core Animation管理图层树，利用Metal框架将图层合成任务交给 GPU 处理，最终通过CAMetalLayer输出到屏幕。

**三、屏幕适配与性能优化**
应用需适应不同设备的屏幕特性，如分辨率、宽高比、刷新率等。以下是关键技术：
1. 动态布局与响应式设计
相对单位：使用密度无关像素（dp）、比例布局或 Flexbox 等技术，确保界面元素随屏幕大小自动调整。
多分辨率适配：通过values-sw600dp等资源目录为不同屏幕尺寸提供特定布局，或利用ConstraintLayout动态约束视图位置。
2. 渲染优化
避免过度绘制：减少重叠的透明图层，通过debugOverdraw工具检测并优化。
硬件加速：开启android:hardwareAccelerated="true"（Android）或使用Metal（iOS）将复杂绘制任务交给 GPU 处理，降低 CPU 负载。
懒加载与虚拟列表：对于长列表应用，仅渲染可见区域的内容，非可见区域的视图暂缓创建或复用，减少内存占用。
3. 后台处理机制
进程挂起：应用退至后台后，系统会暂停其 CPU 调度，仅保留必要的状态（如音乐播放、下载任务）。此时，界面渲染停止，但数据可能继续更新（如消息通知）。
资源回收：当系统内存不足时，后台应用的进程可能被终止，下次启动时需重新渲染界面。开发者可通过onSaveInstanceState保存关键数据，避免用户体验中断。

**总结：从代码到画面的完整链路**

代码定义界面：通过 UI 框架构建视图树，生成绘制指令；

CPU 预处理：将指令转换为 GPU 可处理的顶点和纹理数据；

GPU 渲染：并行计算生成像素颜色，存入后台缓冲区；

图层合成：系统服务将所有应用的图层合成为最终画面；

屏幕显示：通过 VSync 信号同步缓冲区，逐行扫描输出到屏幕。

最终，无数像素的颜色和亮度组合，构成了我们看到的应用界面。这一过程依赖 ** 硬件（CPU/GPU/ 屏幕）、系统（渲染服务、内存管理）、软件（框架、算法）** 的协同，而开发者通过优化渲染流程和适配技术，确保应用在不同设备上流畅、美观地显示。

显示过程中有一个关键的Vsync信号，其作用和原理如下：

**一、为什么需要 VSync？—— 画面撕裂的根源**
显示器的显示原理是逐行扫描：
以常见的 60Hz 屏幕为例，每秒会从屏幕顶部到底部 “扫描” 60 次（每帧约 16.67ms），每次扫描完成后，电子束会从底部快速回到顶部（“垂直回扫期”），准备下一次扫描。
而 GPU 的渲染是独立进行的：它会将渲染好的画面写入 “缓冲器”（如后缓冲），如果渲染速度与屏幕扫描不同步，就会出现问题 ——
画面撕裂的场景：
当屏幕正在扫描第 1 帧的下半部分时，GPU 已经渲染完第 2 帧并写入了缓冲器。此时屏幕会同时显示第 1 帧的上半部分和第 2 帧的下半部分，形成一条明显的 “撕裂线”。

**二、VSync 的核心原理：用信号同步渲染与显示**
VSync 的核心是通过垂直同步信号（VSync Signal）作为 “时间锚点”，强制 GPU 的渲染节奏与屏幕刷新节奏对齐：
信号触发时机：
屏幕每次完成一帧扫描并进入 “垂直回扫期” 时，会发出一个VSync 信号（60Hz 屏幕每秒发 60 次，120Hz 则每秒 120 次）。
GPU 的响应机制：
GPU 只有在收到 VSync 信号后，才会开始渲染下一帧画面，避免在屏幕扫描过程中修改缓冲器数据。
缓冲器交换的时机：
当 GPU 完成一帧渲染（写入后缓冲），会等待下一个 VSync 信号到来，再将 “前缓冲”（正在显示的帧）与 “后缓冲”（刚渲染完的帧）交换。此时屏幕正处于垂直回扫期（不读取缓冲数据），交换过程不会被用户察觉，确保显示的是完整的一帧。

**三、VSync 与缓冲机制的配合：双缓冲与三缓冲**
VSync 的效果依赖于缓冲机制的设计，常见的有 “双缓冲” 和 “三缓冲”：
1. 双缓冲 + VSync（基础方案）
前缓冲（Front Buffer）：正在被屏幕读取显示的缓冲；
后缓冲（Back Buffer）：GPU 正在渲染的缓冲。
流程：
① 屏幕显示前缓冲内容，同时 GPU 等待 VSync 信号；
② VSync 信号到来，GPU 开始向后缓冲渲染下一帧；
③ 渲染完成后，等待下一个 VSync 信号，交换前后缓冲；
④ 屏幕开始显示新的前缓冲（原后缓冲）内容。
2. 三缓冲 + VSync（优化方案）
当 GPU 渲染速度慢于屏幕刷新率（如 60Hz 屏幕，GPU 每帧需要 20ms），双缓冲会导致 “卡顿”：
双缓冲下，GPU 未及时完成渲染，会错过 VSync 信号，屏幕只能继续显示上一帧，导致画面停滞。
三缓冲通过增加一个 “中缓冲” 解决该问题：
当 GPU 错过一个 VSync 信号，可继续渲染到中缓冲；
下一个 VSync 信号到来时，直接交换中缓冲与前缓冲，减少等待时间，降低卡顿概率。

**四、VSync 的优缺点**
优点：
彻底解决画面撕裂，让画面更连贯（尤其在快速移动场景，如游戏、滑动界面）；
规范 GPU 渲染节奏，减少无效渲染（避免 GPU 在屏幕扫描时浪费资源）。
缺点：
可能增加输入延迟：如果 GPU 渲染速度刚好匹配刷新率（如 60fps），延迟较低；但如果渲染速度慢（如 30fps），每帧需要等待 2 个 VSync 周期，延迟翻倍；
对硬件性能有要求：GPU 需在 VSync 周期内完成渲染（如 60Hz 屏幕需 16.67ms 内完成一帧），否则会触发 “掉帧”。

**五、VSync 在系统中的实现**
不同系统对 VSync 的管理略有差异，但核心逻辑一致：
Android：由系统服务SurfaceFlinger生成 VSync 信号，通过Choreographer机制通知应用（如 UI 框架）何时开始渲染，确保应用、GPU、屏幕节奏一致。
iOS：通过Core Animation的CADisplayLink接收 VSync 信号，驱动 UI 刷新和动画渲染，配合Metal框架实现高效同步。
PC / 游戏：显卡驱动（如 NVIDIA G-SYNC、AMD FreeSync）可动态调整 VSync 信号，甚至根据 GPU 性能自适应刷新率（如从 60Hz 降至 48Hz），平衡延迟与流畅度。

**总结**
VSync 的本质是 **“时间同步器”**：通过垂直回扫期的信号，强制 GPU 渲染节奏与屏幕刷新节奏对齐，解决画面撕裂问题。它与双缓冲 / 三缓冲配合，构成了现代显示系统流畅输出的基础，同时也推动了高刷新率屏幕（90Hz、120Hz、144Hz）的普及 —— 更高的刷新率意味着更密集的 VSync 信号，能进一步降低延迟，提升交互流畅度（如滑动屏幕、游戏操作）。
[“终于懂了” 系列：Android屏幕刷新机制—VSync、Choreographer 全面理解！](https://cloud.tencent.com/developer/article/1685247)

### 2、手机应用是怎么开发的？系统是如何支持这些应用的？有哪些技术框架？###

### 3、为什么手机开发要用web这些技术？当前有什么相关的技术，他们有什么优势和不足？####

### 5、如何优化手机操作系统性能？###

# 性能优化技术

1、为什么会有性能问题？通常有哪些性能问题？
   通常说的手机性能问题，主要是应用界面的问题：黑、花、闪，再简化一些，就是卡顿。
   通常原因：资源供给不够（供得慢、供不上），冰山模型（算力等资源保持不变的情况下，系统负载越重，卡顿越严重，冰山（代表卡顿问题）浮出水面越多；否则冰山下沉，系统越流畅）
2、可以从哪些方面入手进行优化？详细的性能优化技术是怎么样的？


## 鸿蒙性能优化
### 鸿蒙架构
<img width="1783" height="866" alt="image" src="https://github.com/user-attachments/assets/304d0b20-00dc-4906-863c-bc36d64b0bdf" />
应用层指的是系统应用和三方应用，系统应用如大桌面、相机、图库这些，三方应用就是指外部应用开发商了，这里涉及了三方的应用技术，如原生的ArkTs/ArkUI、外部的Flutter、RN、XWeb、KMP等

框架层多指代ArkTs、ArkUI这一层级

服务层指底座、RSS资源管理这一层级，RSS这块涉及了内存和CPU的调度管理，是资源管理的核心层级。

再往下就是鸿蒙内核和linux内核以及硬件驱动层了

### 鸿蒙底座

### 服务层
#### 内存管理
手机操作系统的内存管理是保证系统流畅运行、高效利用有限内存资源的核心机制，其核心目标是：**在有限的 RAM（随机存取存储器）中，为前台应用提供充足资源，同时支持多任务切换，并尽可能减少卡顿或崩溃**。

**一、核心任务**
动态分配：为应用、系统进程分配所需内存，确保它们能正常运行。
智能回收：及时回收不再使用的内存（如关闭的后台应用、临时缓存），避免资源浪费。
优先级调度：保证前台应用（用户正在操作的）优先获得内存，后台应用按需 “降级” 或 “冻结”。
避免瓶颈：减少内存泄漏、碎片化，防止因内存不足导致的应用崩溃或系统卡顿。

**二、关键机制详解**
1. 进程优先级管理：谁先 “活”，谁先 “死”
手机系统会给进程划分优先级，内存不足时，低优先级进程会被优先回收，以保障高优先级进程运行。
以安卓为例，进程优先级从高到低分为 5 类（iOS 逻辑类似，但更严格）：
前台进程：用户正在交互的应用（如正在使用的微信、视频软件），优先级最高，几乎不会被回收。
可见进程：虽不在前台，但部分界面可见（如弹出的悬浮窗、后台播放的音乐），优先级次之。
服务进程：后台运行的服务（如下载任务、后台定位），优先级中等，内存紧张时可能被回收。
后台进程：用户退出但未完全关闭的应用（如切换到后台的浏览器），优先级较低，内存不足时优先被清理。
空进程：应用已退出，仅保留进程壳（方便下次快速启动），优先级最低，内存紧张时最先被杀死。
2. 内存分配：如何 “分” 得高效？
虚拟内存技术：手机系统通过 “虚拟地址映射”，让每个应用认为自己独占内存，实际由系统统一管理物理内存（类似电脑的分页机制）。
内存压缩（ZRAM）：将不常用的内存数据压缩后存储（如后台应用的临时数据），需要时解压使用，可节省 30%-50% 内存空间（安卓广泛使用）。
交换分区（Swap）：部分系统（如安卓）会将极少使用的内存数据转移到手机存储（如 EMMC/UFS），释放 RAM，但存储速度远慢于 RAM，可能导致卡顿（现在较少用，多被内存压缩替代）。
3. 内存回收：不够了怎么办？
当内存不足时，系统会启动 “自救” 机制：
OOM Killer（内存不足杀手）：按进程优先级，强制终止低优先级进程（如空进程、后台进程），释放内存给前台应用。
惰性回收：在内存紧张前，主动回收 “可丢弃” 资源（如应用缓存的图片、网页数据），避免突然卡顿。
墓碑机制（iOS 特色）：后台应用进入 “冻结状态”，系统释放其大部分内存，仅保留 “重启信息”（如页面状态），再次打开时快速恢复（类似 “暂停 - 重启”），大幅节省内存。

**三、不同系统的差异**
安卓：开源且灵活，支持更多后台进程，但依赖厂商优化（如 “内存扩展” 用存储模拟 RAM），易因后台进程过多导致卡顿（需手动清理或系统自动杀进程）。
iOS：封闭且严格，后台进程限制更严（多数应用后台后被 “冻结”），内存管理效率更高，卡顿少，但多任务能力较弱（后台应用活跃时间短）。

**四、总结**
手机内存管理的核心是** “平衡”**：既保证前台应用流畅，又最大化利用内存支持多任务。通过优先级调度、智能回收、虚拟内存等技术，系统在有限的硬件资源下，尽可能提升用户体验 —— 这也是为什么大内存手机（如 16GB）更流畅，但高效的内存管理机制比单纯堆硬件更重要。

手机内存回收策略需兼顾低功耗、实时响应和有限硬件资源，以下是常见的核心策略：

**1. 基于进程优先级的回收（最核心）**
系统为每个进程分配优先级（如前台应用＞可见服务＞后台进程＞空进程）。
内存不足时，优先回收优先级最低的进程（如后台空进程），释放其占用的内存，确保前台应用流畅运行。

**2. 惰性回收（延迟释放）**
进程退到后台时，不立即回收其内存，而是暂时保留（缓存状态）。
若用户再次启动该进程，可快速恢复，减少重新加载的时间；当内存紧张时，再触发实际回收。

**3. 内存压缩与交换（Swap）**
内存压缩：对不常用的内存页进行压缩存储，减少占用空间（如 Android 的 ZRAM 技术）。
交换分区（Swap）：将部分不活跃的内存数据暂存到手机存储（如 EMMC/UFS），需要时再换回内存，缓解内存压力（低端机常用，高端机因存储速度限制较少依赖）。

**4. 应用生命周期管理**
系统通过监听应用状态（如 Activity 的 onCreate/onPause/onDestroy），在应用进入后台时，通知其释放非必要资源（如缓存、临时数据）。
强制终止无响应（ANR）或异常耗电的后台进程，释放内存。

**5. 低内存杀手（Low Memory Killer，LMK）**
手机内核中的关键机制，预设不同内存阈值，当可用内存低于某阈值时，触发对应级别的进程查杀（按优先级）。
阈值和回收力度可动态调整（如根据当前内存使用率、电池状态）。

**6. 内存缓存智能清理**
对应用缓存（如图片缓存、数据缓存）设置上限，超过后自动清理部分旧缓存。
系统定期扫描并回收长期未使用的缓存文件（非进程内存，属于存储层面的辅助回收）。
这些策略共同作用，在有限的手机内存中平衡 “应用响应速度” 和 “资源利用率”，避免因内存不足导致的卡顿或崩溃。

#### CPU调度

### Render渲染

## 应用层

### 框架
#### [ArkTs](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-overview?ha_source=sousuo&ha_sourceId=89000251)
#### [Web框架](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-component-overview?ha_source=sousuo&ha_sourceId=89000251)
#### [Flutter](https://flutter.cn/)

#### [RN框架](https://reactnative.cn/)

### 参考资料
[基础课程(华为开发者课堂基础课程)](https://developer.huawei.com/consumer/cn/training/result?type1=101718934267126043&orderBy=1)  
[性能优化](https://developer.huawei.com/consumer/cn/doc/best-practices-V14/bpta-performance-V14)
[学习笔记](https://ai.xmind.cn/JAyQcY8j)


## Android性能优化

### 参考资料
[Android开发者官网(学习Android的模块架构和相关性能优化)](https://developer.android.google.cn/get-started?hl=zh-cn) 
[Android性能优化官网](https://source.android.google.cn/docs/core/perf?hl=zh-cn)
[Android性能优化：这是一份全面 & 详细的性能优化指南（含内存优化、布局优化等）](https://cloud.tencent.com/developer/article/1963763)
[Android 性能优化必知必会](https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/)

## IOS性能优化

### 参考资料
[iOS-Performance-Optimization](https://github.com/shanyuqin/Performance)
[iOS 性能优化](https://juejin.cn/post/7304263961242927138)
[iOS应用性能监控与分析技术深度解析](https://www.cnblogs.com/b86435312/p/18584653)


# MarkDown
[MarkDown语法](https://markdown.com.cn/)
